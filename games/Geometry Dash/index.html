<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Geometry Dash Clone</title>
  <style>
    body {
      margin: 0;
      background: #121212;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: sans-serif;
      color: #fff;
    }
    canvas {
      background: #1f1f1f;
      display: block;
      border: 3px solid #9b59b6;
    }
    #score {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 24px;
    }
    #instructions {
      position: absolute;
      top: 50px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 18px;
      color: #bbb;
    }
  </style>
</head>
<body>
  <div id="score">Score: 0</div>
  <div id="instructions">Press SPACE or CLICK to jump</div>
  <canvas id="gameCanvas" width="800" height="400"></canvas>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Game variables
    let player = { x: 50, y: 300, width: 40, height: 40, dy: 0, jumpPower: 12, gravity: 0.6 };
    let obstacles = [];
    let gameSpeed = 5;
    let score = 0;
    let gameOver = false;

    // Jump function
    function jump() {
      if (player.y >= canvas.height - player.height) {
        player.dy = -player.jumpPower;
      }
    }

    // Event listeners
    document.addEventListener('keydown', (e) => { if(e.code === "Space") jump(); });
    canvas.addEventListener('mousedown', jump);

    // Create obstacles periodically
    function spawnObstacle() {
      const height = 30 + Math.random() * 70;
      obstacles.push({ x: canvas.width, y: canvas.height - height, width: 30, height: height });
    }

    setInterval(spawnObstacle, 1500);

    // Game loop
    function update() {
      if(gameOver) return;

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Player physics
      player.dy += player.gravity;
      player.y += player.dy;
      if(player.y > canvas.height - player.height) {
        player.y = canvas.height - player.height;
        player.dy = 0;
      }

      // Draw player
      ctx.fillStyle = "#e74c3c";
      ctx.fillRect(player.x, player.y, player.width, player.height);

      // Update and draw obstacles
      for(let i = obstacles.length - 1; i >= 0; i--) {
        const obs = obstacles[i];
        obs.x -= gameSpeed;

        ctx.fillStyle = "#3498db";
        ctx.fillRect(obs.x, obs.y, obs.width, obs.height);

        // Collision detection
        if(player.x < obs.x + obs.width &&
           player.x + player.width > obs.x &&
           player.y < obs.y + obs.height &&
           player.y + player.height > obs.y) {
             gameOver = true;
             alert("Game Over! Score: " + score);
             location.reload();
        }

        // Remove offscreen obstacles
        if(obs.x + obs.width < 0) {
          obstacles.splice(i,1);
          score++;
          document.getElementById('score').innerText = "Score: " + score;
        }
      }

      requestAnimationFrame(update);
    }

    update();
  </script>
</body>
</html>
